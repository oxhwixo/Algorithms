## 정렬

### 선택 정렬

가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음으로 작은 데이터를 선택해서 앞에서 두 번째 있는 데이터와 바꾸는 과정을 반복하는 정렬 방식이다.
시간 복잡도는 O(n^2^) 이다.

```python
array = [7, 5, 9, 0, 3, 1]

for i in range(len(array)):
	min_index = i
	for j in range(i + 1, len(array)):
		if array[min_index] > array[j]:
			min_index = j
	array[i], array[min_index] = array[min_index], array[i]

print(array)
```

### 삽입 정렬

데이터를 하나씩 확인하며 적절한 위치에 삽입하는 정렬방식이다. 삽입정렬은 두 번째 데이터부터 시작하는데, 왜냐하면 첫 번째 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.
삽입 정렬은 필요할 때만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 훨씬 효율적이다. 이 때는 퀵 정렬 알고리즘보다 더 강력하다.
삽입 정렬의 시간 복잡도는 O(N^2^) 인데, 최선의 경우에는 O(N)의 복잡도를 가진다.

```python
array = [7, 5, 9, 0, 3, 1]

for i in range(1, len(array)):
	for j in range(i, 0, -1):
		if array[j] < array[j - 1]:
			array[j], array[j - 1] = array[j - 1], array[j]
		else:
			break

print(array)
```

### 퀵 정렬

퀵 정렬은 기준 데이터를 설정한 다음, 그 수보다 큰 수, 작은 수를 교환하여 리스트를 교환한 후에 리스트를 반으로 나누는 방식으로 동작한다. 이 기준을 바로 피벗이라고 표현하는데, 피벗을 설정하고 리스트를 분할하는 방법에 따라서 여러 가지 방식으로 퀵 정렬을 구분한다.

#### 리스트를 분할하는 방법

1. 로무토 분할
   마지막 element를 피벗으로 사용한다. i는 배열의 맨 왼쪽 원소 index - 1, j는 맨 왼쪽 index (0) 부터 시작한다. j가 피봇 바로 전 index까지 가는 동안 반복문을 통해 만약 j가 가리키는 값이 피봇값보다 같거나 작다면 i 에 1을 더한다. 그리고 i 가 가리키는 값과 j 가 가리키는 값을 교환한다.
   마지막으로 i + 1 위치와 피봇 값을 교환하면 피봇 값이 제 위치에 들어가게 된다.
2. 호어 분할
   첫 element를 피벗으로 사용한다. 피벗보다 큰 값은 오른쪽, 작은 값들은 왼쪽 집합에 위치시킨다. i 는 피봇의 바로 다음 인덱스, j는 맨 끝 인덱스로 시작한다. j 가 i 를 역전하여 교차하기 전 까지 (i < = j)반복문을 진행한다.
   i 위치의 값이 피벗보다 같거나 큰 값을 가지는지 확인하고, j 위치의 값이 피벗보다 같거나 작은 값을 가지는지 확인한다. 만약에 두 값 모두 원하는 값을 찾는다면 두 값을 서로 교환하고 i 에는 1을 더해주고, j 에는 1을 빼준다. 만약 i만 원하는 값을 찾았다면 j 에 1을 빼주고, j만 원하는 값을 찾았을 때에는 i에 1을 더해준다. 반복문 탈출 후에는 피벗값과 j가 가리키는 값을 교환한다.
